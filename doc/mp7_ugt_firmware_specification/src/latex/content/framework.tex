\section{Framework}\label{sec:framework:framework}

This description is for version v1.2.4 of Framework.\\

\textbf{Remark:}\\
with frame v1.2.3 "Delay Manager" (dm.vhd) and "Data Source Multiplexer" (dsmux.vhd) are removed because these features were never used in production system, only for tests.
Simmem data not useable anymore, because of removed dsmux.
The reason of removing is to get more available resources.\\

Figure \ref{fig_system_overview} shows the basic components of Framework together with \rop.

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{./figures/system_overview}
\caption{System architecture overview}
\label{fig_system_overview}
\end{figure}

The central data type of Framework is shown in Listing \ref{lst:fw:lst_lhc_data_t} (see Section \ref{sec:fw:section_lhc_data_pkg} for details). In the current configuration it comprises 2304 bits (288 Bytes). Data from the GTH interfaces is demultiplexed (from 240 MHz clock domain to LHC clock domain, see Demux Lane Data \ref{sec:framework:demux_lane_data}) and mapped to this data type in the LMP (Lane Mapping Process). It is also used as input and output type for the SIM/SPY I memory.

\subsection{Implementation in firmware}
\label{sec:framework:implementation_firmware}

Listing~\ref{lst:framework:frame_vhd} contains the entity-declaration of the \texttt{frame.vhd}.\\

\lstinputlisting[label=lst:framework:frame_vhd,language=VHDL,caption=Entity declaration of \texttt{frame.vhd}]{interfaces/frame.vhd}

\medskip
\begin{table}
\footnotesize
\caption{Explanation of Listing~\ref{lst:framework:frame_vhd}}
\vspace{5mm}
\centering
\begin{tabular}{l p{.7\columnwidth}}
\toprule
{Item} & {Explanation}\\
\midrule
\verb|NR_LANES| & number of used optical links.\\
\verb|ipb_clk| & IPBus clock input.\\
\verb|ipb_rst| & IPBus reset input.\\
\verb|ipb_in| & IPBus data input.\\
\verb|ipb_out| & IPBus data output.\\
\verb|ctrs| & TTC control signals input.\\
\verb|clk240| & clock input 240 MHz.\\
\verb|lhc_clk| & clock input (LHC clock).\\
\verb|lhc_rst_o| & reset output.\\
\verb|bc0| & TTC BGo bunch counter reset input.\\
\verb|ec0| & TTC BGo event counter reset input.\\
\verb|oc0| & TTC BGo orbit counter reset input.\\
\verb|start| & TTC BGo start input.\\
\verb|l1a| & L1 access signal input.\\
\verb|bcres_d| & delayed bunch counter reset output.\\
\verb|bcres_d_FDL| & delayed bunch counter reset output fot FDL.\\
\verb|start_lumisection| & begin of lumisection output.\\
\verb|lane_data_in| & data from GTHs (optical links) input (240MHz domain).\\
\verb|lane_data_out| & data to GTHs (optical links) output (240MHz domain).\\
\verb|lhc_data_2_gtl_o| & data to GTL output (40MHz domain).\\
\verb|prescale_factor_set_in| & prescale factor set data input.\\
\verb|algo_after_gtLogic_rop| & algos after GTL input.\\
\verb|algo_after_bxomask_rop| & algos after BX mask input.\\
\verb|algo_after_prescaler_rop| & algos after prescaler input.\\
\verb|local_finor_rop| & local FINOR input.\\
\verb|local_veto_rop| & local VETO input.\\
\verb|finor_rop| & FINOR input.\\
\verb|local_finor_with_veto_2_spy2| & local FINOR with VETO to spy mem input.\\
\bottomrule
\end{tabular}
\label{tab:framework:explanation_frame_vhd}
\end{table}

\clearpage
\subsection{Configuration of optical connections} \label{sec:framework:sec_configuration_optical_conn}
The configuration of the optical connections to Calo-Layer2 is (currently) done as described in Table~\ref{tab:framework:tab_configuration_optical_conn}, where
frame means the 32 bits data (240 MHz) within a LHC clock period.

\begin{table}
\caption{Configuration of optical connections}
\vspace{5mm}
\centering
\begin{tabular}{c|m{.13\columnwidth}|m{.13\columnwidth}|m{.13\columnwidth}|m{.13\columnwidth}|m{.13\columnwidth}|m{.13\columnwidth}|}
\cline{2-7}
 & \multicolumn{6}{c|}{\textbf{frame}} \\\hline
\multicolumn{1}{|c|}{\textbf{link}} & \makebox[.13\columnwidth][c]{\textbf{0}} & \makebox[.13\columnwidth][c]{\textbf{1}} & \makebox[.13\columnwidth][c]{\textbf{2}} & \makebox[.13\columnwidth][c]{\textbf{3}} & \makebox[.13\columnwidth][c]{\textbf{4}} &\makebox[.13\columnwidth][c]{\textbf{5}} \\\hline\hline
\multicolumn{1}{|c|}{0} & reserved & reserved & muon obj. 0 [0..31] & muon obj. 0 [32..63] & muon obj. 1 [0..31] & muon obj. 1 [32..63]\\\hline
\multicolumn{1}{|c|}{1} & reserved & reserved & muon obj. 2 [0..31] & muon obj. 2 [32..63] & muon obj. 3 [0..31] & muon obj. 3 [32..63]\\\hline
\multicolumn{1}{|c|}{2} & reserved & reserved & muon obj. 4 [0..31] & muon obj. 4 [32..63] & muon obj. 5 [0..31] & muon obj. 5 [32..63]\\\hline
\multicolumn{1}{|c|}{3} & reserved & reserved & muon obj. 6 [0..31] & muon obj. 6 [32..63] & muon obj. 7 [0..31] & muon obj. 7 [32..63]\\\hline
\multicolumn{1}{|c|}{4} & \egamma obj. 0 & \egamma obj. 1 & \egamma obj. 2 & \egamma obj. 3 & \egamma obj. 4 & \egamma obj. 5 \\\hline
\multicolumn{1}{|c|}{5} & \egamma obj. 6 & \egamma obj. 7 & \egamma obj. 8 & \egamma obj. 9 & \egamma obj. 10 & \egamma obj. 11 \\\hline
\multicolumn{1}{|c|}{6} & jet obj. 0 & jet obj. 1 & jet obj. 2 & jet obj. 3 & jet obj. 4 & jet obj. 5 \\\hline
\multicolumn{1}{|c|}{7} & jet obj. 6 & jet obj. 7 & jet obj. 8 & jet obj. 9 & jet obj. 10 & jet obj. 11 \\\hline
\multicolumn{1}{|c|}{8} & tau obj. 0 & tau obj. 1 & tau obj. 2 & tau obj. 3 & tau obj. 4 & tau obj. 5 \\\hline
\multicolumn{1}{|c|}{9} & tau obj. 6 & tau obj. 7 & tau obj. 8 & tau obj. 9 & tau obj. 10 & tau obj. 11 \\\hline
\multicolumn{1}{|c|}{\multirow{3}{*}{10}} &
\multicolumn{1}{l|}{\ett} & \htt & \etm & \htm & ET$_{miss}^{HF}$ & HT$_{miss}^{HF}$ \\
\multicolumn{1}{|c|}{} &
\multicolumn{1}{l|}{ETTEM} & TOWER-COUNT & ASYMET & ASYMHT & ASYM-ETHF & ASYM-HTHF \\
\multicolumn{1}{|c|}{} &
\multicolumn{1}{l|}{MBT0HFP} & MBT0HFM & MBT1HFP & MBT1HFM & CENT[3:0] & CENT[7:4] \\\hline
\multicolumn{1}{|c|}{11} & free & free & free & free & free & free \\\hline
\multicolumn{1}{|c|}{12} & external-conditions [0..31] & external-conditions [32..63] & reserved & reserved & reserved & reserved \\\hline
\multicolumn{1}{|c|}{13} & external-conditions [64..95] & external-conditions [96..127] & reserved & reserved & reserved & reserved \\\hline
\multicolumn{1}{|c|}{14} & external-conditions [128..159] & external-conditions [160..191] & reserved & reserved & reserved & reserved \\\hline
\multicolumn{1}{|c|}{15} & external-conditions [192..223] & external-conditions [224..255] & reserved & reserved & reserved & reserved \\\hline
\end{tabular}
\label{tab:framework:tab_configuration_optical_conn}
\end{table}

%------------------------------------------------------------------------------
%
%  Demux Lane data
%
% ------------------------------------------------------------------------------

\subsection{Demux Lane Data} \label{sec:framework:demux_lane_data}
Data from GTH interfaces is in the 240 MHz clock domain. The demultiplexing to the LHC clock domain (about 40 MHz) is done in demux\_lane\_data.vhd, which is instantiated
in frame.vhd as often as lanes are used (currently 16 lanes are used).

%------------------------------------------------------------------------------
%
%  Lane Mapping Process
%
% ------------------------------------------------------------------------------

\subsection{Lane Mapping Process} \label{sec:framework:lmp}
In the Lane Mapping Process module data from the lanes are mapped to objects structure defined in lhc\_data\_pkg.vhd.

\subsubsection{Implementation}\label{sec:framework:lmp_impl}
Currently lane mapping is "fixed" in lmp.vhd module, see Table \ref{tab:framework:current_lane_mapping} (\esums\textsuperscript{1}: including minimum bias trigger bits, towercounts, asymmetry and centrality bits).

\begin{table}[ht]
\caption{Current lane mapping}
\vspace{5mm}
\centering
\begin{tabular}{|c|l|c|}\hline
\textbf{lane} & \textbf{objects} \\\hline\hline
0 & muon objects 0..1 \\\hline
1 & muon objects 2..3 \\\hline
2 & muon objects 4..5 \\\hline
3 & muon objects 6..7 \\\hline
4 & \egamma objects 0..5 \\\hline
5 & \egamma objects 6..11 \\\hline
6 & jet object 0..5 \\\hline
7 & jet object 6..11 \\\hline
8 & tau object 0..5 \\\hline
9 & tau object 6..11 \\\hline
10 & \esums\footnotemark \\\hline
11 & n/a (currently not used) \\\hline
12 & external-conditions [0..63] \\\hline
13 & external-conditions [64..127] \\\hline
14 & external-conditions [128..191] \\\hline
15 & external-conditions [192..255] \\\hline
\end{tabular}
\label{tab:framework:current_lane_mapping}
\end{table}

%------------------------------------------------------------------------------
%
%  SIM and SPY Memory
%
% ------------------------------------------------------------------------------

\subsection{SIM and SPY Memory}\label{sec:framework:sim-spy}
\textbf{Remark:}\\
with frame v1.2.3 Simmem data not useable anymore, because of removed "Data Source Multiplexer".
The reason of removing "Data Source Multiplexer" is to get more available resources.\\

Figure \ref{fig_simspy} shows the SIM/SPY memory subsystem of Framework.
It is used to calibrate the system, i.e. to record results of the GTL/FDL and output packages of the ROP.

\subsubsection{Implementation}\label{sec:framework:sim_spy_impl}
The memory subsystem consists of four main parts, which will be discussed in more detail in the following sections

\begin{itemize}
\item SPY Trigger
\item SIM/SPY Memory
\item SPY Memory II
\item SPY Memory III
\end{itemize}

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{./figures/simspy}
\caption{Memory subsystem}
\label{fig_simspy}
\end{figure}

\paragraph{SPY Trigger}\label{sec:framework:spy_trigger}
The SPY trigger controls the SPY memories and decides when data is recorded. It can be configured and controlled using
software registers \ref{spy_trig_obrit_nr_reg} and \ref{spy_trig_cfg_reg} provided by the \hyperref[sec_rb]{register bank}.

\begin{register}{htbp}{SPY Trigger Orbit Number Registers}{}% name=CONFIG
	\label{spy_trig_obrit_nr_reg}
	\regfield{orbit\_nr\_low}{32}{0}{0}%
	\regfield{reserved}{16}{16}{0}%
	\regfield{orbit\_nr\_high}{16}{0}{0}%
	\begin{regdesc}
	\begin{reglist}[Request~Depth]
		\item [orbit\_nr\_low] The 32 low bits of the 48 bit orbit number, used for the spy once trigger.
		\item [orbit\_nr\_high] The 16 high bits of the 48 bit orbit number, used for the spy once trigger.
	\end{reglist}
	\end{regdesc}
\end{register}

\begin{register}{htbp}{SPY Trigger Configuration Register}{}% name=CONFIG
	\label{spy_trig_cfg_reg}%
	\regfield{spy12\_bsy}{1}{31}{0}%
	\regfield{spy3\_bsy}{1}{30}{0}%
	\regfield{spy12\_rdy}{1}{29}{0}%
	\regfield{spy3\_rdy}{1}{28}{0}%
	\regfield{spy12\_err}{1}{27}{0}%
	\regfield{reserved}{21}{6}{0}%
	\regfield{clr\_spy12\_err}{1}{5}{0}%
	\regfield{clr\_spy3\_rdy}{1}{4}{0}%
	\regfield{clr\_spy12\_rdy}{1}{3}{0}%
	\regfield{spy3}{1}{2}{0}%
	\regfield{spy12\_next}{1}{1}{0}%
	\regfield{spy12\_once}{1}{0}{0}%
	\reglabel{Reset}\regnewline%

	\begin{regdesc}
	\begin{reglist}[Request~Depth]
		\item [spy12\_once] Triggers the recording of the selected orbit to SPY memories I and II, when written with 1.
		\item [spy12\_next] Triggers the recording of the next whole orbit to SPY memories I and II, when written with 1.
		\item [spy3] Triggers the recording of the next package that will be sent by the ROP to SPY memory III, when written with 1.
		\item [clr\_spy12\_rdy] Clears the ready flag of the SPY trigger for SPY memories I and II, when written with 1.
		\item [clr\_spy3\_rdy] Clears the ready flag of the SPY trigger for SPY memory III, when written with 1.
		\item [clr\_spy12\_err] Clears the error flag, when written with 1.
		\item [spy12\_bsy] Indicates that the SPY trigger for SPY memories I and II is busy.
		\item [spy3\_bsy] Indicates that the SPY trigger for SPY memory III is busy.
		\item [spy12\_rdy] Indicates that one orbit has been recorded in SPY memories I and II and that the SPY trigger is ready for new commands.
		\item [spy3\_rdy] Indicates that packet has been recorded in SPY memory III and that the SPY trigger is ready for new commands.
		\item [spy12\_err] Indicates an error condition (Set only when the selected orbit number for the spy once trigger lies in the past and can therefore not be recorded).
	\end{reglist}
	\end{regdesc}
\end{register}

When the SPY trigger receives a spy12 command (next or once) over the software register interface it asserts the $spy1$ and $spy2$ signals for the appropriate orbit.
This means that the $spy$ signals go high with the bunch crossing counter reaching the value zero and stay high until it reaches zero again (overflow). Note that when
the SIM memory is being used (indicated by the $simem\_in\_use\_i$ input provided by the DSMUX component) the $spy1$ output will not be asserted.

When a spy3 command is received the SPY trigger asserts the $spy3$ signal and waits until the $spy3\_ack$ signal is asserted.

\paragraph{SIM/SPY memory}
This component combines the SIM memory and the SPY memory I. This optimization is possible because these two memories are never used at the same time. There are basically
two use cases for this memory.
\begin{itemize}
\item SIM memory: Data is read form the memory and provided to GTL and ROP to test these components.
\item SPY memory: External data is received by the GTX and stored in the memory to check the alignment of the data.
\end{itemize}
It is very important to guarantee that the spy input signal is not asserted, as long as the memory is used as SIM memory. Note that this functionality is implemented in
the SPY trigger component.

The SIM/SPY memory converts the $lhc\_data\_i$ input signal to a \texttt{std\_logic\_vector} using the converter function provided by the \texttt{lhc\_data\_pkg}. This vector
is then divided into chunks of 32 bits (the PCIe data width). For each of these chunks a 32 bit true-dual-port memory (2 read ports, 2 write ports, 2 clock domains) is instanciated.
Thus, every memory has a read/write port in both clock domain, the 125MHz PCIe clock domain and the 40MHz LHC clock domain, which can be used simultaneously.
The PCIe data-in signal ($sw\_i.data$) is connected to PCIe-clock domain write port of the memories. A memory select signal is generated form the LSBs of the software address ($sw\_i.addr$).
The memory select signal also controls the multiplexer on the output of the memories to generate the $sw\_o.data$ signal.

Depending on whether the SIM/SPY memory is used to provide simulation data or to store/spy data the address on the LHC-clock domain port of the internal memories is adjusted.
If data is recorded (SPY) the bunch crossing counter is used as memory address directly.
When the memory is read the read latency (two clock cycles) must be taken into account.
This is achieved by subtracting 2 form the bunch crossing number before using it as address.
To generate the $lhc\_data\_o$ signal the LHC-clock domain data out ports of the internal memories are concatenated and converted back to the \texttt{lhc\_data\_t}.

If the \texttt{lhc\_data\_t} is changed (e.g. new objects added) no modifications in the SIM/SPY memory are required. The SIM/SPY memory only depends on the (auto-generated)
functions used to convert a \texttt{lhc\_data\_t} signal to \texttt{std\_logic\_vector} and vice versa (see Section \ref{sec:fw:section_lhc_data_pkg} for details).

In the current implementation the size every object in the \texttt{lhc\_data\_t} is a multiple of 32 bit. This is also expected by the SIM/SPY memory. If objects with 16 bit sizes
are added the SIM/SPY memory must be modified to support this situation (e.g. zero pad the \texttt{lhc\_data\_t}). Furthermore take into account that the PCIe memory bus is 32 bits wide.
So 16 bit objects should be added to the end of the \texttt{lhc\_data\_t} (as last entry) to keep software memory access simple.

\paragraph{SPY memory II}
The SPY memory II is divided into two subcomponents, to store the $algos$ and $finor$ outputs of the FDL.
Both memory can only be read over the SW interface. A write access has no effect.
% Tables \ref{tab_spy2_algos} and \ref{tab_spy2_finor} show the memory layout as seen by the software.
The algos memory uses the same architecture as the SIM memory.
The finor memory uses a true-dual-port memory with asymmetric ports. This memory can be written with a data width of one bit and read with a data width of 32 bit.

% Note that the start addresses of the algos and finor memories (configured in the address decoder) must be a multiples of their sizes (in the current configuration $2^{16}$ and $2^7$).
%
\paragraph{SPY memory III}
The SPY memory III stores the output of the ROP, which is sent to the DAQ. The input data width is configurable to bus widths of 16, 32 or 64 bits.
Depending on the input data width the memory uses different architectures.
\begin{itemize}
\item 16 Bit \\
A true-dual-port memory with asymmetric ports (16 and 32 bits) is used.
\item 32 Bit \\
A true-dual-port memory with 32 Bit data width is used.
\item 64 Bit \\
Two true-dual-port memories with 32 Bit data width are used.
\end{itemize}

\subsubsection{Interface Specification}

\begin{minipage}{\textwidth}
\lstinputlisting[language=VHDL,caption=SPY trigger interface specification]{interfaces/spytrig.vhd}
\end{minipage}

%------------------------------------------------------------------------------
%
%  TCM
%
% ------------------------------------------------------------------------------
\subsection{Timer Counter Manager}\label{sec:framework:tcm}

The Timer Counter Manager (TCM) provides different counters, listed in table \ref{tab:framework:tcm_counters} and a set of resisters.

\subsubsection{Counter Overview}
\begin{table}[H]
\vspace{5mm}
\begin{scriptsize}
\begin{tabular}{|l|l|l|l|l|}
\hline
Counter             &range              &increase condition               &reset condition           &Comments     \\ \hline
bx\_nr              &$0 to 3563$        &rising\_edge(lhc\_clk)           &overflow                  &             \\ \hline
event\_nr           &$0 to 2^{32}-1$    &l1a=1 and rising\_edge(lhc\_clk) &BGOS: event counter reset &             \\ \hline
trigger\_nr         &$0 to 2^{48}-1$    &l1a=1 and rising\_edge(lhc\_clk) &BGOS: start run           &             \\ \hline
orbit\_nr           &$0 to 2^{48}-1$    &overflow of bx\_nr               &BGOS: orbit counter reset &             \\ \hline
luminosity\_seg\_nr &$0 to 2^{32}-1$    &rising\_edge(orbit\_nr(18))      &BGOS: orbit counter reset &             \\ \hline
start\_lumisection  &$0 to 1$           &luminosity\_seg\_nr increases    &after 25ns                &'1' for 25ns \\ \hline
bx\_nr\_d\_fdl      &$0 to 3563$       &rising\_edge(lhc\_clk)            &overflow                  &             \\ \hline
\end{tabular}\caption{Counters of Timer Counter Manager}\label{tab:framework:tcm_counters}
\end{scriptsize}
\end{table}

\subsubsection{Bunch Crossing Number and counters derived from it}
All counters except for event\_nr and the trigger\_nr (which are trivial because they are increased with l1a) are dependent on the bunch crossing counter bx\_nr as stated in table \ref{tab:framework:tcm_counters}. The bx\_nr is zero at startup, then waits for the the first bcres\_d (bunch crossing reset delayed) and starts counting as depicted in figure \ref{fig:bx_start}. It's maximal value is 3563 (0xdeb), then it automatically overflows and starts at zero again (see figure \ref{fig:bx_normal_operation}). Exactly when bx\_nr = 0, bcres\_d has to be asserted. Otherwise the counter is out of synchronization. If this happens, the software register err\_det is set and the counter waits for the next bcres\_d to synchronize again. Note that the value of the counter is invalid until it has synchronized again.

\begin{figure}[ht]
  \includegraphics[width=1.0\textwidth]{./figures/bx_start}
  \caption{start of the bunch crossing number with the first bcres\_d}
  \label{fig:bx_start}
\end{figure}

\begin{figure}[ht]
  \includegraphics[width=1.0\textwidth]{./figures/bx_normal_operation}
  \caption{normal operation of the bunch crossing number}
  \label{fig:bx_normal_operation}
\end{figure}

\subsubsection{Special counter: bx\_nr\_d\_fdl}
The bx\_nr\_d\_fdl is derived from bcres\_d\_fdl in the same manner as bx\_nr is derived from bcres\_d. bx\_nr\_d\_fdl will automatically resync if the logic described in subsection \ref{subsec:framework:tcmerrors} detects a synchronization error for bx\_nr.

\subsubsection{Counters derived from l1a}
The counters event\_nr and trigger\_nr are increased with l1a, i.e. they are increased twice if l1a is high for 2 clock cycles, etc. They differ only in their value range and the condition that resets the counters, see table \ref{tab:framework:tcm_counters}.

\subsubsection{Errors}\label{subsec:framework:tcmerrors}
As stated above, bcres\_d has to be asserted exactly when bx\_nr = 0, otherwise the counter is out of sync. Then the software register err\_det is set as depicted in figure \ref{fig:err_det}. err\_det can be reset via the software event register err\_det\_reset\_event as depicted in figure \ref{fig:err_det_reset}. Furthermore err\_det is set if bgos = Resync-0x1 and the counter value is not 3563.

\begin{figure}[ht]
  \includegraphics[width=1.0\textwidth]{./figures/err_det}
  \caption{set of the software register err\_det when bc\_res\_d is not asserted correctly}
  \label{fig:err_det}
\end{figure}

\begin{figure}[ht]
  \includegraphics[width=1.0\textwidth]{./figures/err_det_reset}
  \caption{reset of the software register err\_det when err\_det\_reset\_event toggles}
  \label{fig:err_det_reset}
\end{figure}

The TCM implements two additional counters (bx\_nr\_chk and bx\_nr\_max) for debugging purposes. These counters are not visible by any other module but readable via software. bx\_nr\_chk is a 32bit Counter that increases with every LHC clock cycle and resets with bcres\_d. bx\_r\_max holds the highest value bx\_nr\_chk ever reached (should be 3563 if the link is aligned).

\subsubsection{SW-Registers}
All counters except for the start\_lumisection described in table \ref{tab:framework:tcm_counters} can be read by software via the following sw registers:

\begin{register}{H}{TCM Bunch Crossing Number Register}{}%
	\regfield{reserved}{20}{12}{0}%
	\regfield{bx\_nr}{12}{0}{0}%
	\begin{regdesc}
	\end{regdesc}
\end{register}
\begin{register}{H}{TCM Event Number Register}{}%
	\regfield{event\_nr}{32}{0}{0}%
	\begin{regdesc}
	\end{regdesc}
\end{register}
\begin{register}{H}{TCM Trigger Number Registers}{}%
	\regfield{trigger\_nr\_l}{32}{0}{0}%
	\regfield{reserved}{16}{16}{0}%
	\regfield{trigger\_nr\_h}{16}{0}{0}%
	\begin{regdesc}
	\begin{reglist}[Request~Depth]
		\item [trigger\_nr\_l] The 32 low bits of the 48 bit trigger number.
		\item [trigger\_nr\_h] The 16 high bits of the 48 bit trigger number.
	\end{reglist}
	\end{regdesc}
\end{register}
\begin{register}{H}{TCM Orbit Number Registers}{}%
	\regfield{orbit\_nr\_l}{32}{0}{0}%
	\regfield{reserved}{16}{16}{0}%
	\regfield{orbit\_nr\_h}{16}{0}{0}%
	\begin{regdesc}
	\begin{reglist}[Request~Depth]
		\item [orbit\_nr\_l] The 32 low bits of the 48 bit orbit number.
		\item [orbit\_nr\_h] The 16 high bits of the 48 bit orbit number.
	\end{reglist}
	\end{regdesc}
\end{register}
\begin{register}{H}{TCM Luminosity Segment Number Register}{}%
	\regfield{luminosity\_seg\_nr}{32}{0}{0}%
	\begin{regdesc}
	\end{regdesc}
\end{register}
\begin{register}{H}{TCM Bunch Crossing Number FDL Register}{}%
	\regfield{reserved}{20}{12}{0}%
	\regfield{bx\_nr\_d\_fdl}{12}{0}{0}%
	\begin{regdesc}
	\end{regdesc}
\end{register}
\begin{register}{H}{TCM Bunch Crossing Number Check Register}{}%
	\regfield{bx\_nr\_chk}{32}{0}{0}%
	\begin{regdesc}
	\end{regdesc}
\end{register}
\begin{register}{H}{TCM Bunch Crossing Number Max Register}{}%
	\regfield{bx\_nr\_max}{32}{0}{0}%
	\begin{regdesc}
	\end{regdesc}
\end{register}

Some additional control register can be used to check and reset err\_det, disable the check of bcres\_d and bcres\_d\_fdl (bx\_nr and bx\_nr\_d\_fdl automatically reset when they overflow if cmd\_ign\_bcres is set, bcres\_d is ignored) and simulate the bgos signal. To do this, a value of the orbit signal has to be written to sw-register bgos. The value of the input signal bgos is replaced by the value of the sw-register for exactly one clock cycle, when "1" is written to the event register bgos\_event.

\begin{register}{H}{TCM cmd\_ign\_bcres}{}% name=CONFIG
	\label{cmd_ign_bcres}%
 	\regfield{reserved}{31}{1}{0}%
 	\regfield{cmd\_ign\_bcres}{1}{0}{0}%
	\reglabel{Reset}\regnewline%

	\begin{regdesc}
	\begin{reglist}[Request~Depth]
 		\item [cmd\_ign\_bcres] bcres is ignored (not checked) when this is set.
	\end{reglist}
	\end{regdesc}
\end{register}

\begin{register}{H}{TCM err\_det}{}% name=CONFIG
	\label{err_det}%
 	\regfield{reserved}{31}{1}{0}%
	\regfield{err\_det}{1}{0}{0}%
	\reglabel{Reset}\regnewline%

	\begin{regdesc}
	\begin{reglist}[Request~Depth]
		\item [err\_det] Set when out of synchronization.
	\end{reglist}
	\end{regdesc}
\end{register}

\begin{register}{H}{TCM err\_det\_reset\_event}{}% name=CONFIG
	\label{err_det_reset_event}%
 	\regfield{reserved}{31}{1}{0}%
 	\regfield{err\_det\_reset\_event}{1}{0}{0}%
	\reglabel{Reset}\regnewline%

	\begin{regdesc}
	\begin{reglist}[Request~Depth]
 		\item [err\_det\_reset\_event] Event register: resets err\_det.
	\end{reglist}
	\end{regdesc}
\end{register}

\begin{register}{H}{TCM bgos}{}% name=CONFIG
	\label{bgos}%
 	\regfield{reserved}{31}{4}{0}%
 	\regfield{bgos}{4}{0}{0}%
	\reglabel{Reset}\regnewline%

	\begin{regdesc}
	\begin{reglist}[Request~Depth]
 		\item [bgos] For simulation of the bgos signal.
	\end{reglist}
	\end{regdesc}
\end{register}

\begin{register}{H}{TCM bgos\_event}{}% name=CONFIG
	\label{bgos_event}%
 	\regfield{reserved}{31}{1}{0}%
 	\regfield{bgos\_event}{1}{0}{0}%
	\reglabel{Reset}\regnewline%

	\begin{regdesc}
	\begin{reglist}[Request~Depth]
 		\item [bgos\_event] Event register: replaces the input signal bgos by the sw-register bgos for exactly one clock cycle.
	\end{reglist}
	\end{regdesc}
\end{register}

\begin{register}{H}{TCM luminosity\_seg\_period\_msk}{}% name=CONFIG
	\label{luminosity_seg_period_msk}%
 	\regfield{luminosity\_seg\_period\_msk}{32}{0}{0x40000}%
	\reglabel{Reset} %\regnewline%

	\begin{regdesc}
	\begin{reglist}[Request~Depth]
 		\item [luminosity\_seg\_period\_msk] luminosity\_seg\_nr is increased when the orbit\_nr mod lum\_seg\_period\_mask = 0.
	\end{reglist}
	\end{regdesc}
\end{register}

% \subsubsection{Hardware Test}
% There are various python scripts located in the software/GtControl/branches/fpga-design-2013/python/GtControl >>>>>????????? old??<<<<<<<<<  directory for testing the tcm module. Please refer to the output of the scripts for information how the tests are performed in detail. See table \ref{tab:tcm_hw_test}.
% \begin{table}[ht]
% \vspace{5mm}
% \begin{scriptsize}
% \begin{tabular}{|p{5cm}|p{10cm}|}
% \hline
% script                         &purpose    \\ \hline
% \verb|tcm_counter_values.py|   &outputs the values of all counters defined above    \\ \hline
% \verb|tcm_produce_err_det|     &produces an err\_det by manipulating bgos \\ \hline
% \verb|tcm_err_det_reset|       &resets the err\_det software register \\ \hline
% \verb|tcm_trigger_test|        &tests trigger\_nr and event\_nr by generating l1a signals using l1asim \\ \hline
% \verb|tcm_lum_seg_nr_test|    &checks the period of two successive increases of the luminositiy\_seg\_nr \\ \hline
% \end{tabular}\caption{scripts for testing the tcm}\label{tab:tcm_hw_test}
% \end{scriptsize}
% \end{table}

\subsection{Software Reset} \label{sec:framework:software_reset}
The software reset module (sw\_reset) provides the possiblity for a software reset via the software event register sw\_reset\_event.

\begin{register}{htbp}{Software Reset register}{}% name=CONFIG
	\label{tcm_ctrl_reg}%
	\regfield{reserved}{31}{1}{0}%
	\regfield{sw\_reset\_event}{1}{0}{0}%
	\reglabel{Reset}\regnewline%

	\begin{regdesc}
	\begin{reglist}[Request~Depth]
		\item [sw\_reset\_event] Event register: Generates a reset signal for exactly one clock cycle.
	\end{reglist}
	\end{regdesc}
\end{register}

\clearpage

